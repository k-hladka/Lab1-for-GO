package main

import "fmt"

func main() {
	var x, y, z uint8

	x = 9
	y = 28
	z = x

	fmt.Println("Битовые операции")
	/* Всі бітові операції працюють з двійковими значеннями, що означає,
	   що спочатку значення переводиться з десяткової форми в двійкову, а потім вже виконується бітова операція.
	   Після виконання бітової операції значення знову переводиться в десяткову форму
	*/
	fmt.Printf("^x      = ^(%d)      = ^(%.8b)            = %.8b = %d\n", x, x, ^x, ^x)
	// 9 в двійковій системі = 1001
	// унарний оператор ^ для кожного біта повертає йому протилежний. Тобто, для 0 поверне 1, а для 1 - 0
	// 00001001 перетворюється в 11110110 що в десятковій системі = 246

	fmt.Printf("x << 2  = (%d << 2)  = (%.8b << 2)        = %.8b = %d\n", x, x, x<<2, x<<2)
	// В цьому прикладі виконується операція зсуву вліво на 2 символи.
	// Спочатку 9 переводиться в двійкову форму
	// Далі перші два біти відкидаються, а вкінець дописуємо нулі.
	// Виходить 00100100 що в десятковій формі = 36

	fmt.Printf("x >> 2  = (%d >> 2)  = (%.8b >> 2)        = %.8b = %d\n", x, x, x>>2, x>>2)
	// В цьому прикладі виконується операція зсуву вправо на 2 символи.
	// Спочатку 9 переводиться у двійкову форму
	// Далі останні два біти відкидаються, а на початок дописуємо нулі.
	// Виходить 00000010 що в десятковій формі = 2

	fmt.Printf("x & y   = (%d & %d)  = (%.8b & %.8b)  = %.8b = %d\n", x, y, x, y, x&y, x&y)
	// Операція 'і', де 1 отримуємо лише у випадку 1&1, все решта - 0

	fmt.Printf("x | y   = (%d | %d)  = (%.8b | %.8b)  = %.8b = %d\n", x, y, x, y, x|y, x|y)
	// Операція або, де 0 отримуємо лише у випадку 0|0, все решта - 1

	fmt.Printf("x ^ y   = (%d ^ %d)  = (%.8b ^ %.8b)  = %.8b = %d\n", x, y, x, y, x^y, x^y)
	// Бінарний оператор ^, який повертає 1, якщо ми маємо два різні біти 1^0. Все решта = 0

	fmt.Printf("x &^ y  = (%d &^ %d) = (%.8b &^ %.8b) = %.8b = %d\n", x, y, x, y, x&^y, x&^y)
	// Повертає 1 тільки коли 1&^0, все решта 0

	fmt.Printf("x %% y   = (%d %% %d)  = (%.8b %% %.8b)  = %.8b = %d\n", x, y, x, y, x%y, x%y)
	// Повертає 1 тільки коли перший біт = 1, тобто 1%0 або 1%1

	/*Нижче написані ті ж операції, просто з присвоюванням.
	  Спочатку виконується переведення з двійкового типу в десятковий.
	  Далі обраховується операція, після чого йде перетворення в двійковий тип.
	  Результат записується в змінну.
	*/
	fmt.Println("\nБитовые операции с присваиванием")
	x = z
	x &= y
	fmt.Printf("x &= y   = (%d &= %d)  = (%.8b &= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x |= y
	fmt.Printf("x |= y   = (%d |= %d)  = (%.8b |= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x ^= y
	fmt.Printf("x ^= y   = (%d ^= %d)  = (%.8b ^= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x &^= y
	fmt.Printf("x &^= y  = (%d &^= %d) = (%.8b &^= %.8b) = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x %= y
	fmt.Printf("x %%= y   = (%d %%= %d)  = (%.8b %%= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)

	//Задание.
	//1. Пояснить результаты операций
}
